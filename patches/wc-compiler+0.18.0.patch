diff --git a/node_modules/wc-compiler/src/jsx-loader.js b/node_modules/wc-compiler/src/jsx-loader.js
index 4316647..eb3221b 100644
--- a/node_modules/wc-compiler/src/jsx-loader.js
+++ b/node_modules/wc-compiler/src/jsx-loader.js
@@ -39,8 +39,8 @@ export function getParser(moduleURL) {
     config: {
       // https://github.com/acornjs/acorn/issues/829#issuecomment-1172586171
       ...walk.base,
-      JSXElement: () => {}
-    }
+      JSXElement: () => {},
+    },
   };
 }
 
@@ -57,7 +57,9 @@ function applyDomDepthSubstitutions(tree, currentDepth = 1, hasShadowRoot = fals
           const { value } = attrs[attr];
 
           if (value.indexOf('__this__.') >= 0) {
-            const root = hasShadowRoot ? '.getRootNode().host' : `${'.parentElement'.repeat(currentDepth)}`;
+            const root = hasShadowRoot
+              ? '.getRootNode().host'
+              : `${'.parentElement'.repeat(currentDepth)}`;
 
             node.attrs[attr].value = value.replace(/__this__/g, `this${root}`);
           }
@@ -75,7 +77,7 @@ function applyDomDepthSubstitutions(tree, currentDepth = 1, hasShadowRoot = fals
   return tree;
 }
 
-function parseJsxElement(element, moduleContents = '') {
+function parseJsxElement(element, moduleContents = '', inferredObservability = false) {
   try {
     const { type } = element;
 
@@ -122,8 +124,14 @@ function parseJsxElement(element, moduleContents = '') {
 
               if (left.object.type === 'ThisExpression') {
                 if (left.property.type === 'Identifier') {
-                  // very naive (fine grained?) reactivity
-                  string += ` ${name}="__this__.${left.property.name}${expression.operator}${right.raw}; __this__.render();"`;
+                  if (inferredObservability) {
+                    // very naive (fine grained?) reactivity
+                    // string += ` ${name}="__this__.${left.property.name}${expression.operator}${right.raw}; __this__.update(\\'${left.property.name}\\', null, __this__.${left.property.name});"`;
+                    string += ` ${name}="__this__.${left.property.name}${expression.operator}${right.raw}; __this__.setAttribute(\\'${left.property.name}\\', __this__.${left.property.name});"`;
+                  } else {
+                    // implicit reactivity using this.render
+                    string += ` ${name}="__this__.${left.property.name}${expression.operator}${right.raw}; __this__.render();"`;
+                  }
                 }
               }
             }
@@ -151,6 +159,11 @@ function parseJsxElement(element, moduleContents = '') {
                   }
                 }
               }
+
+              // TODO make sure this only applies to `this` references!
+              if (inferredObservability) {
+                string += ` data-wcc-${expression.name}="${name}" data-wcc-ins="attr"`;
+              }
             }
           } else {
             // xxx >
@@ -162,7 +175,9 @@ function parseJsxElement(element, moduleContents = '') {
       string += openingElement.selfClosing ? '/>' : '>';
 
       if (element.children.length > 0) {
-        element.children.forEach(child => parseJsxElement(child, moduleContents));
+        element.children.forEach((child) =>
+          parseJsxElement(child, moduleContents, inferredObservability),
+        );
       }
 
       string += `</${tagName}>`;
@@ -177,6 +192,13 @@ function parseJsxElement(element, moduleContents = '') {
 
       if (type === 'Identifier') {
         // You have {count} TODOs left to complete
+        if (inferredObservability) {
+          const { name } = element.expression;
+
+          string = `${string.slice(0, string.lastIndexOf('>'))} data-wcc-${name}="\${this.${name}}" data-wcc-ins="text">`;
+        }
+        // TODO be able to remove this extra data attribute
+        // string = `${string.slice(0, string.lastIndexOf('>'))} data-wcc-${name} data-wcc-ins="text">`;
         string += `$\{${element.expression.name}}`;
       } else if (type === 'MemberExpression') {
         const { object } = element.expression.object;
@@ -207,26 +229,33 @@ function findThisReferences(context, statement) {
   const references = [];
   const isRenderFunctionContext = context === 'render';
   const { expression, type } = statement;
-  const isConstructorThisAssignment = context === 'constructor'
-    && type === 'ExpressionStatement'
-    && expression.type === 'AssignmentExpression'
-    && expression.left.object.type === 'ThisExpression';
+  const isConstructorThisAssignment =
+    context === 'constructor' &&
+    type === 'ExpressionStatement' &&
+    expression.type === 'AssignmentExpression' &&
+    expression.left.object.type === 'ThisExpression';
 
   if (isConstructorThisAssignment) {
     // this.name = 'something'; // constructor
     references.push(expression.left.property.name);
   } else if (isRenderFunctionContext && type === 'VariableDeclaration') {
-    statement.declarations.forEach(declaration => {
+    statement.declarations.forEach((declaration) => {
       const { init, id } = declaration;
 
       if (init.object && init.object.type === 'ThisExpression') {
         // const { description } = this.todo;
         references.push(init.property.name);
       } else if (init.type === 'ThisExpression' && id && id.properties) {
-        // const { description } = this.todo;
+        // const { id, description } = this;
         id.properties.forEach((property) => {
           references.push(property.key.name);
         });
+      } else {
+        // TODO we are just blindly tracking anything here.
+        // everything should ideally be mapped to actual this references, to create a strong chain of direct reactivity
+        // instead of tracking any declaration as a derived tracking attr
+        // for convenience here, we push the entire declaration here, instead of the name like for direct this references (see above)
+        references.push(declaration);
       }
     });
   }
@@ -238,7 +267,7 @@ export function parseJsx(moduleURL) {
   const moduleContents = fs.readFileSync(moduleURL, 'utf-8');
   const result = transform(moduleContents, {
     transforms: ['typescript', 'jsx'],
-    jsxRuntime: 'preserve'
+    jsxRuntime: 'preserve',
   });
   // would be nice if we could do this instead, so we could know ahead of time
   // const { inferredObservability } = await import(moduleURL);
@@ -248,45 +277,77 @@ export function parseJsx(moduleURL) {
   let observedAttributes = [];
   let tree = acorn.Parser.extend(jsx()).parse(result.code, {
     ecmaVersion: 'latest',
-    sourceType: 'module'
+    sourceType: 'module',
   });
   string = '';
 
-  walk.simple(tree, {
-    ClassDeclaration(node) {
+  // TODO: would be nice to do this one pass, but first we need to know if `inferredObservability` is set first
+  walk.simple(
+    tree,
+    {
+      ExportNamedDeclaration(node) {
+        const { declaration } = node;
+
+        if (
+          declaration &&
+          declaration.type === 'VariableDeclaration' &&
+          declaration.kind === 'const' &&
+          declaration.declarations.length === 1
+        ) {
+          // @ts-ignore
+          if (declaration.declarations[0].id.name === 'inferredObservability') {
+            // @ts-ignore
+            inferredObservability = Boolean(node.declaration.declarations[0].init.raw);
+          }
+        }
+      },
+    },
+    {
+      // https://github.com/acornjs/acorn/issues/829#issuecomment-1172586171
+      ...walk.base,
       // @ts-ignore
-      if (node.superClass.name === 'HTMLElement') {
-        const hasShadowRoot = moduleContents.slice(node.body.start, node.body.end).indexOf('this.attachShadow(') > 0;
+      JSXElement: () => {},
+    },
+  );
 
-        for (const n1 of node.body.body) {
-          if (n1.type === 'MethodDefinition') {
-            // @ts-ignore
-            const nodeName = n1.key.name;
-            if (nodeName === 'render') {
-              for (const n2 in n1.value.body.body) {
-                const n = n1.value.body.body[n2];
-
-                if (n.type === 'VariableDeclaration') {
-                  observedAttributes = [
-                    ...observedAttributes,
-                    ...findThisReferences('render', n)
-                  ];
-                  // @ts-ignore
-                } else if (n.type === 'ReturnStatement' && n.argument.type === 'JSXElement') {
-                  const html = parseJsxElement(n.argument, moduleContents);
-                  const elementTree = getParse(html)(html);
-                  const elementRoot = hasShadowRoot ? 'this.shadowRoot' : 'this';
-
-                  applyDomDepthSubstitutions(elementTree, undefined, hasShadowRoot);
-
-                  const serializedHtml = serialize(elementTree);
-                  // we have to Shadow DOM use cases here
-                  // 1. No shadowRoot, so we attachShadow and append the template
-                  // 2. If there is root from the attachShadow signal, so we just need to inject innerHTML, say in an htmx
-                  // could / should we do something else instead of .innerHTML
-                  // https://github.com/ProjectEvergreen/wcc/issues/138
-                  const renderHandler = hasShadowRoot
-                    ? `
+  walk.simple(
+    tree,
+    {
+      ClassDeclaration(node) {
+        // @ts-ignore
+        if (node.superClass.name === 'HTMLElement') {
+          const hasShadowRoot =
+            moduleContents.slice(node.body.start, node.body.end).indexOf('this.attachShadow(') > 0;
+
+          for (const n1 of node.body.body) {
+            if (n1.type === 'MethodDefinition') {
+              // @ts-ignore
+              const nodeName = n1.key.name;
+              if (nodeName === 'render') {
+                for (const n2 in n1.value.body.body) {
+                  const n = n1.value.body.body[n2];
+
+                  if (n.type === 'VariableDeclaration') {
+                    observedAttributes = [
+                      ...observedAttributes,
+                      ...findThisReferences('render', n),
+                    ];
+                    // @ts-ignore
+                  } else if (n.type === 'ReturnStatement' && n.argument.type === 'JSXElement') {
+                    const html = parseJsxElement(n.argument, moduleContents, inferredObservability);
+                    const elementTree = getParse(html)(html);
+                    const elementRoot = hasShadowRoot ? 'this.shadowRoot' : 'this';
+
+                    applyDomDepthSubstitutions(elementTree, undefined, hasShadowRoot);
+
+                    const serializedHtml = serialize(elementTree);
+                    // we have to Shadow DOM use cases here
+                    // 1. No shadowRoot, so we attachShadow and append the template
+                    // 2. If there is root from the attachShadow signal, so we just need to inject innerHTML, say in an htmx
+                    // could / should we do something else instead of .innerHTML
+                    // https://github.com/ProjectEvergreen/wcc/issues/138
+                    const renderHandler = hasShadowRoot
+                      ? `
                         const template = document.createElement('template');
                         template.innerHTML = \`${serializedHtml}\`;
 
@@ -297,38 +358,29 @@ export function parseJsx(moduleURL) {
                           this.shadowRoot.innerHTML = template.innerHTML;
                         }
                       `
-                    : `${elementRoot}.innerHTML = \`${serializedHtml}\`;`;
-                  const transformed = acorn.parse(renderHandler, {
-                    ecmaVersion: 'latest',
-                    sourceType: 'module'
-                  });
-
-                  // @ts-ignore
-                  n1.value.body.body[n2] = transformed;
+                      : `${elementRoot}.innerHTML = \`${serializedHtml}\`;`;
+                    const transformed = acorn.parse(renderHandler, {
+                      ecmaVersion: 'latest',
+                      sourceType: 'module',
+                    });
+
+                    // @ts-ignore
+                    n1.value.body.body[n2] = transformed;
+                  }
                 }
               }
             }
           }
         }
-      }
+      },
     },
-    ExportNamedDeclaration(node) {
-      const { declaration } = node;
-
-      if (declaration && declaration.type === 'VariableDeclaration' && declaration.kind === 'const' && declaration.declarations.length === 1) {
-        // @ts-ignore
-        if (declaration.declarations[0].id.name === 'inferredObservability') {
-          // @ts-ignore
-          inferredObservability = Boolean(node.declaration.declarations[0].init.raw);
-        }
-      }
-    }
-  }, {
-    // https://github.com/acornjs/acorn/issues/829#issuecomment-1172586171
-    ...walk.base,
-    // @ts-ignore
-    JSXElement: () => {}
-  });
+    {
+      // https://github.com/acornjs/acorn/issues/829#issuecomment-1172586171
+      ...walk.base,
+      // @ts-ignore
+      JSXElement: () => {},
+    },
+  );
 
   // TODO - signals: use constructor, render, HTML attributes?  some, none, or all?
   if (inferredObservability && observedAttributes.length > 0 && !hasOwnObservedAttributes) {
@@ -336,18 +388,48 @@ export function parseJsx(moduleURL) {
     for (const line of tree.body) {
       // test for class MyComponent vs export default class MyComponent
       // @ts-ignore
-      if (line.type === 'ClassDeclaration' || (line.declaration && line.declaration.type) === 'ClassDeclaration') {
+      if (
+        line.type === 'ClassDeclaration' ||
+        (line.declaration && line.declaration.type) === 'ClassDeclaration'
+      ) {
         // @ts-ignore
         insertPoint = line.declaration.body.start + 1;
       }
     }
 
     let newModuleContents = generate(tree);
-
-    // TODO better way to determine value type?
+    const trackingAttrs = observedAttributes.filter((attr) => typeof attr === 'string');
+    // TODO ideally derivedAttrs would explicitly reference trackingAttrs
+    // and if there are no derivedAttrs, do not include the derivedGetters / derivedSetters code in the compiled output
+    const derivedAttrs = observedAttributes.filter((attr) => typeof attr !== 'string');
+    const derivedGetters = derivedAttrs
+      .map((attr) => {
+        return `
+        get_${attr.id.name}(${trackingAttrs.join(',')}) {
+          console.log('@@@@@@@@@@@@@@@@@@@@ updating derivative value for => ${attr.id.name}');
+          console.log('@@@@@@@@@@@@@@@@@@@@ new derivative value is =>', ${moduleContents.slice(attr.init.start, attr.init.end)});
+          return ${moduleContents.slice(attr.init.start, attr.init.end)}
+        }
+      `;
+      })
+      .join('\n');
+    const derivedSetters = derivedAttrs
+      .map((attr) => {
+        const name = attr.id.name;
+
+        return `
+        const old_${name} = this.get_${name}(oldValue);
+        const new_${name} = this.get_${name}(newValue);
+        this.update('${name}', old_${name}, new_${name});
+      `;
+      })
+      .join('\n');
+
+    // TODO: better way to determine value type, e,g. array, int, object, etc?
+    // TODO: better way to test for shadowRoot presence when running querySelectorAll
     newModuleContents = `${newModuleContents.slice(0, insertPoint)}
       static get observedAttributes() {
-        return [${[...observedAttributes].map(attr => `'${attr}'`).join(',')}]
+        return [${[...trackingAttrs].map((attr) => `'${attr}'`).join()}]
       }
 
       attributeChangedCallback(name, oldValue, newValue) {
@@ -362,25 +444,62 @@ export function parseJsx(moduleURL) {
         }
         if (newValue !== oldValue) {
           switch(name) {
-            ${observedAttributes.map((attr) => {
-              return `
-                case '${attr}':
-                  this.${attr} = getValue(newValue);
-                  break;
-              `;
-            }).join('\n')}
+            ${trackingAttrs
+              .map((attr) => {
+                return `
+                  case '${attr}':
+                    this.${attr} = getValue(newValue);
+                    break;
+                `;
+              })
+              .join('\n')}
           }
+          this.update(name, oldValue, newValue);
+        }
+      }
 
-          this.render();
+      update(name, oldValue, newValue) {
+        console.debug('Update tracking against....', this.constructor.observedAttributes);
+        console.debug('Updating', name);
+        console.debug('Swap old', oldValue);
+        console.debug('For new', newValue);
+        console.debug('this[name]', this[name]);
+        const attr = \`data-wcc-\${name}\`;
+        const selector = \`[\${attr}]\`;
+        console.debug({ attr });
+        console.debug({ selector });
+
+        (this?.shadowRoot || this).querySelectorAll(selector).forEach((el) => {
+          const needle = oldValue || el.getAttribute(attr);
+          console.debug({ el })
+          console.debug({ needle });
+          console.debug({ newValue });
+          switch(el.getAttribute('data-wcc-ins')) {
+            case 'text':
+              el.textContent = el.textContent.replace(needle, newValue);
+              break;
+            case 'attr':
+              if (el.hasAttribute(el.getAttribute(attr))) {
+                el.setAttribute(el.getAttribute(attr), newValue);
+              }
+              break;
+          }
+        })
+
+        if ([${[...trackingAttrs].map((attr) => `'${attr}'`).join()}].includes(name)) {
+          ${derivedSetters}
         }
+        console.debug('****************************');
       }
 
+      ${derivedGetters}
+
       ${newModuleContents.slice(insertPoint)}
     `;
 
     tree = acorn.Parser.extend(jsx()).parse(newModuleContents, {
       ecmaVersion: 'latest',
-      sourceType: 'module'
+      sourceType: 'module',
     });
   }
 
@@ -395,7 +514,7 @@ export function resolve(specifier, context, defaultResolve) {
   if (jsxRegex.test(specifier) || tsxRegex.test(specifier)) {
     return {
       url: new URL(specifier, parentURL).href,
-      shortCircuit: true
+      shortCircuit: true,
     };
   }
 
@@ -409,7 +528,7 @@ export async function load(url, context, defaultLoad) {
     return {
       format: 'module',
       source: generate(jsFromJsx),
-      shortCircuit: true
+      shortCircuit: true,
     };
   }
 
